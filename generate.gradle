//Sample tasks used by reactor.

//A lite core
def includingCoreScope = ['amb',
						  'array',
						  'callable',
						  /*'concatarray' ,*/ //managed by reactor-core
						  /*'concatiterable' ,*/ //managed by reactor-core
						  'error',
						  'empty',
						  'next',
						  /*'flatmap' ,*/ //managed by reactor-core
						  'ignoreelements',
						  'iterable',
						  'just',
						  /*'lift',*/ //managed by reactor-core
						  'map',
						  'never',
						  'peek',
						  'resume',
						  /*'zip'*/] //managed by reactor-core

//A complete RS commons coverage minus the lite core
def excludingStreamScope = includingCoreScope + ['generate',
												 'completablefuture',
												 'concatarray',
												 'concatiterable',
												 'flatmap',
												 'lift', //Already managed by reactor-stream
												 'stream',
												 'zip']

//Common reactor helper references
def reactorCommon = ['fn-backport'          : 'reactor.fn',
					 'api-single'           : 'reactor.Mono',
					 'api-single-operator'  : 'reactor.Mono.MonoBarrier',
					 'test-type'            : false,
					 'extra-packages'      : 'reactor.core',
					 'header'               : '@since 2.5',
					 'SubscriptionHelper'   : 'BackpressureUtils',
					 'BackpressureHelper'   : 'BackpressureUtils',
					 'UnsignalledExceptions': 'Exceptions',
					 //'SubscriberDeferSubscription'     : 'reactor.core.subscriber.SubscriberDeferSubscription',
					 //'SubscriberMultiSubscription': 'reactor.core.subscriber.SubscriberMultiSubscription',
					 //'ScalarSubscription'         : 'reactor.core.subscription.SubscriberScalar',
					 //'SubscriberDeferScalar'  : 'reactor.core.subscriber.SubscriberScalarDelayed',
					 'SimpleProcessor'      : 'reactor.core.processor.EmitterProcessor']

//Reactor Core configuration
def reactorCore = ['api'                 : 'reactor.Flux',
				   'api-package'         : 'reactor.core.publisher',
				   'api-operator'        : 'reactor.Flux.FluxBarrier',
				   'serializedSubscriber': false,
				   'include'             : includingCoreScope] + reactorCommon

//Reactor Stream configuration
def reactorStream = ['api'                 : 'reactor.rx.Stream',
					 'api-package'         : 'reactor.rx.stream',
					 'api-operator'        : 'StreamBarrier',
					 'serializedSubscriber': 'reactor.rx.subscriber',
					 'exclude'             : excludingStreamScope,
					 'internal'            : false] + reactorCommon

def defaultTarget = reactorStream

// ----------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------
// Generation Script - Inlining Reactive Streams Commons
// ----------------------------------------------------------------------------------------------------------------
// ----------------------------------------------------------------------------------------------------------------

def defaultSingleAPI = ['empty',
						'just',
						'error',
						'single',
						'ignoreelements',
						'callable',
						'first',
						'next',
						'collect',
						'reduce',
						'all',
						'any',
						'count',
						'elementat',
						'isempty',
						'reduce',

]

task generateTargetAPI(type: Sync) {
  description = 'Deploy Reactive Streams Commons source code to the target API, effectively generating source code in' +
		  ' target directory.'

  outputs.upToDateWhen { false }
  includeEmptyDirs = false

  def target = defaultTarget


  def license = "\n/**\n * {@see <a href='https://github.com/reactor/reactive-streams-commons'>https://github.com/reactor/reactive-streams-commons</a>}\n * $target.header\n */"
  def apiBarrierClass = target['api-operator']
  def apiClass = target['api']
  def splitted = apiClass.split('\\.')
  def apiClassName = splitted[splitted.length - 1]

  from 'src/main/java/reactivestreams/commons/publisher'
  into "build/generated_api/${target['api-package'].replaceAll('\\.', '/')}"

  if (target.include) {
	include { details ->
	  !details.file.name
			  .startsWith('Publisher') || details.file.name
			  .replaceFirst('Publisher', '')
			  .replaceAll(".java", '')
			  .toLowerCase() in target.include
	}
  }


  exclude { details ->
	def name = details.file.name
			.replaceFirst('Publisher', '')
			.replaceAll(".java", '')
			.toLowerCase()

	details.file.name
			.startsWith('Publisher') && (name in target.exclude || name in defaultSingleAPI)
  }

  rename { String fileName -> fileName.replace('Publisher', apiClassName)
  }

  filter { String line -> replaceLine(line, target, license, apiClassName, apiBarrierClass, apiClass)
  }
}


task generateTargetSingleAPI(type: Copy) {
  description = 'Generate Single type artifacts for target integration'

  includeEmptyDirs = false

  def target = defaultTarget

  def apiSingleClass = target['api-single']
  def apiSingleBarrierClass = target['api-single-operator']
  def splitted = apiSingleClass.split('\\.')
  def apiSingleClassName = splitted[splitted.length - 1]

  def license = "\n/**\n * {@see https://github.com/reactor/reactive-streams-commons}\n * $target.header\n */"

  from 'src/main/java/reactivestreams/commons/publisher'
  into "build/generated_api/${target['api-package'].replaceAll('\\.', '/')}"

  include { details ->
	def name = details.file.name
			.replaceFirst('Publisher', '')
			.replaceAll(".java", '')
			.toLowerCase()
	!details.file.name
			.startsWith('Publisher') || (( !target.include || name in target.include) && name in defaultSingleAPI)
  }


  exclude { details ->
	def name = details.file.name
			.replaceFirst('Publisher', '')
			.replaceAll(".java", '')
			.toLowerCase()

	details.file.name
			.startsWith('Publisher') && (name in target.exclude)
  }

  rename { String fileName -> fileName.replace('Publisher', apiSingleClassName)
  }

  filter { line -> replaceLine(line, target, license, apiSingleClassName, apiSingleBarrierClass, apiSingleClass)
  }
}

task generateExtra(type: Copy) {
  description = 'Generate extra package (subscriber, subscription, processor, support) for target integration'

  def target = defaultTarget
  includeEmptyDirs = false

  def license = "\n/**\n * {@see <a href='https://github.com/reactor/reactive-streams-commons'>https://github.com/reactor/reactive-streams-commons</a>}\n * $target.header\n */"
  def apiBarrierClass = target['api-operator']
  def apiClass = target['api']
  def splitted = apiClass.split('\\.')
  def apiClassName = splitted[splitted.length - 1]

  from 'src/main/java/reactivestreams/commons'
  into "build/generated_api/${target['extra-packages']?.replaceAll('\\.', '/')}"

  exclude '**/publisher/**'

  if (target.containsKey('test-type') && !target['test-type']) {
	exclude '**/subscriber/test/**'
  }

  if (target.containsKey('serializedSubscriber') && !target['serializedSubscriber']) {
	exclude '**/subscriber/SerializedSubscriber.java'
  }

  if (target.SimpleProcessor) {
	exclude '**/SimpleProcessor.java'
  }

  if (target.SubscriptionHelper) {
	exclude '**/SubscriptionHelper.java'
  }

  if (target.BackpressureHelper) {
	exclude '**/BackpressureHelper.java'
  }

  if (target.UnsignalledExceptions) {
	exclude '**/UnsignalledExceptions.java'
  }

  filter { line -> replaceLine(line, target, license, apiClassName, apiBarrierClass, apiClass)
  }
}

task inlineCommons {
  description = 'Generate all necessary artifacts for target integration'
  dependsOn generateTargetAPI

  def target = defaultTarget

  if (target['extra-packages']) {
	dependsOn generateExtra
  }

  if (target['api-single']) {
	dependsOn generateTargetSingleAPI
  }
}

private replaceLine(line, target, license, apiClassName, apiBarrierClass, apiClass) {
  if (line.trim().startsWith('package')) {
	if (target['extra-packages'] && !line.contains("publisher")) {
	  return line.replace('reactivestreams.commons', target['extra-packages'])
	}
	else if (target['api-package']) {
	  return line.replace('reactivestreams.commons.publisher', target['api-package'])
	}
	else {
	  return line
	}
  }

  if (line.trim().startsWith('import')) {
	def l = line
	if (target.SimpleProcessor) {
	  l = l.replace("reactivestreams.commons.processor.SimpleProcessor", target.SimpleProcessor)
	}

	if (target['fn-backport']) {
	  l = l.replace('java.util.function', target['fn-backport'])
	}

	if (target['api-package']) {
	  l = l.replace('reactivestreams.commons.publisher', target['api-package'])
	}

	if (target['serializedSubscriber']) {
	  l = l.replace('reactivestreams.commons.subscriber.SerializedSubscriber', target['serializedSubscriber']+".SerializedSubscriber")
	}

	if (target['extra-packages']) {
	  l = l.replace('reactivestreams.commons', target['extra-packages'])
	}

	if (l.contains('BackpressureHelper') && target['BackpressureHelper']) {
	  l = l.replace('BackpressureHelper', target['BackpressureHelper'])
	}
	else if (l.contains('SubscriptionHelper') && target['SubscriptionHelper']) {
	  l = l.replace('SubscriptionHelper', target['SubscriptionHelper'])
	}
	else if (l.contains('UnsignalledExceptions') && target['UnsignalledExceptions']) {
	  l = l.replace('UnsignalledExceptions', target['UnsignalledExceptions'])
	}

	return l;
  }

  def l = line
		  .replace("extends PublisherSource", "extends $apiBarrierClass")
		  .replaceAll("implements Publisher([^,]*),", "extends $apiClass\$1 implements")
		  .replace("implements Publisher", "extends $apiClass")
		  .replace('public final class Publisher', "$license\npublic final class $apiClassName")

  //Special case for just
  if (l.contains('implements Supplier<T>, Publisher<T>')) {
	return l.replace(', Publisher<T>', '').replace('Just<T>', "Just<T> extends $apiClass<T>")
  }


  l = l.replaceAll('Publisher([A-Z][^A-Z]*)', "$apiClassName\$1")


  if (l.contains('BackpressureHelper') && target['BackpressureHelper']) {
	l = l.replace('BackpressureHelper', target['BackpressureHelper'])
  }
  else if (l.contains('SubscriptionHelper') && target['SubscriptionHelper']) {
	l = l.replace('SubscriptionHelper', target['SubscriptionHelper'])
  }
  else if (l.contains('UnsignalledExceptions') && target['UnsignalledExceptions']) {
	l = l.replace('UnsignalledExceptions', target['UnsignalledExceptions'])
  }

  if (target.SimpleProcessor) {
	l = l.replace('SimpleProcessor', target.SimpleProcessor)
  }

  return l
}